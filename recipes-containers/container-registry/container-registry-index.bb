# SPDX-FileCopyrightText: Copyright (C) 2025 Bruce Ashfield
#
# SPDX-License-Identifier: MIT
#
# container-registry-index.bb
# ===========================================================================
# Push OCI container images to a registry (like package-index for containers)
# ===========================================================================
#
# This is the container equivalent of meta/recipes-core/meta/package-index.bb
# It discovers OCI images in DEPLOY_DIR_IMAGE and pushes them to a registry.
#
# Usage:
#   # Start registry first (separate terminal):
#   oe-run-native docker-distribution-native registry serve config.yml
#
#   # Push all container images to registry:
#   bitbake container-registry-index
#
#   # Or use the helper script:
#   oe-run-native container-registry-index
#
# Configuration (in local.conf):
#   CONTAINER_REGISTRY_URL = "localhost:5000"
#   CONTAINER_REGISTRY_NAMESPACE = "yocto"
#   CONTAINER_REGISTRY_IMAGES = "container-base container-app"  # optional filter
#
# ===========================================================================

SUMMARY = "Populate container registry with OCI images"
LICENSE = "MIT"

INHIBIT_DEFAULT_DEPS = "1"
PACKAGES = ""

inherit nopackages container-registry

deltask do_fetch
deltask do_unpack
deltask do_patch
deltask do_configure
deltask do_compile
deltask do_install
deltask do_populate_lic
deltask do_populate_sysroot

do_container_registry_index[nostamp] = "1"
do_container_registry_index[network] = "1"
do_container_registry_index[depends] += "skopeo-native:do_populate_sysroot"

python do_container_registry_index() {
    import os

    registry = d.getVar('CONTAINER_REGISTRY_URL')
    namespace = d.getVar('CONTAINER_REGISTRY_NAMESPACE')
    specific_images = (d.getVar('CONTAINER_REGISTRY_IMAGES') or '').split()

    bb.plain(f"Container Registry Index: {registry}/{namespace}/")

    # Discover OCI images
    all_images = container_registry_discover_oci_images(d)

    if not all_images:
        bb.warn("No OCI images found in deploy directory")
        bb.plain(f"Deploy directory: {d.getVar('DEPLOY_DIR_IMAGE')}")
        bb.plain("Build container images first: bitbake container-base")
        return

    bb.plain(f"Found {len(all_images)} OCI images")

    # Filter if specific images requested
    if specific_images:
        images = [(path, name) for path, name in all_images if name in specific_images]
    else:
        images = all_images

    # Push each image
    pushed_refs = []
    for oci_path, image_name in images:
        bb.plain(f"Pushing: {image_name}")
        refs = container_registry_push(d, oci_path, image_name)
        pushed_refs.extend(refs)

    bb.plain(f"Pushed {len(pushed_refs)} image references to {registry}")
}

addtask do_container_registry_index before do_build

# Generate a helper script with paths baked in
# Script is placed alongside registry storage (outside tmp/) so it persists
CONTAINER_REGISTRY_SCRIPT = "${CONTAINER_REGISTRY_STORAGE}/container-registry.sh"

python do_generate_registry_script() {
    import os
    import stat
    import shutil

    script_path = d.getVar('CONTAINER_REGISTRY_SCRIPT')
    deploy_dir = d.getVar('DEPLOY_DIR')
    deploy_dir_image = d.getVar('DEPLOY_DIR_IMAGE')

    # Find registry binary path
    native_sysroot = d.getVar('STAGING_DIR_NATIVE') or ''
    registry_bin = os.path.join(native_sysroot, 'usr', 'sbin', 'registry')

    # Find skopeo binary path
    skopeo_bin = os.path.join(d.getVar('STAGING_SBINDIR_NATIVE') or '', 'skopeo')

    # Registry settings
    registry_url = d.getVar('CONTAINER_REGISTRY_URL')
    registry_namespace = d.getVar('CONTAINER_REGISTRY_NAMESPACE')
    registry_storage = d.getVar('CONTAINER_REGISTRY_STORAGE')
    tag_strategy = d.getVar('CONTAINER_REGISTRY_TAG_STRATEGY') or 'latest'
    target_arch = d.getVar('TARGET_ARCH') or ''

    # Create storage directory
    os.makedirs(registry_storage, exist_ok=True)
    os.makedirs(deploy_dir, exist_ok=True)

    # Copy config file to storage directory and update storage path
    src_config = os.path.join(d.getVar('THISDIR'), 'files', 'container-registry-dev.yml')
    config_file = os.path.join(registry_storage, 'registry-config.yml')
    with open(src_config, 'r') as f:
        config_content = f.read()
    # Replace the default storage path with actual path
    config_content = config_content.replace(
        'rootdirectory: /tmp/container-registry',
        f'rootdirectory: {registry_storage}'
    )
    with open(config_file, 'w') as f:
        f.write(config_content)

    script = f'''#!/bin/bash
# Container Registry Helper Script
# Generated by: bitbake container-registry-index -c generate_registry_script
#
# This script has all paths pre-configured for your build.
#
# Usage:
#   {script_path} start                     # Start registry server
#   {script_path} stop                      # Stop registry server
#   {script_path} status                    # Check if running
#   {script_path} push [options]            # Push OCI images to registry
#   {script_path} import <image>            # Import 3rd party image
#   {script_path} list                      # List all images with tags
#   {script_path} tags <image>              # List tags for an image
#   {script_path} catalog                   # List image names (raw API)
#
# Push options:
#   --tag <tag>           Explicit tag (can be repeated)
#   --strategy <strats>   Tag strategy: timestamp, sha, branch, semver, latest, arch
#   --version <ver>       Version for semver strategy (e.g., 1.2.3)

set -e

# Pre-configured paths from bitbake
REGISTRY_BIN="{registry_bin}"
SKOPEO_BIN="{skopeo_bin}"
REGISTRY_CONFIG="{config_file}"
REGISTRY_STORAGE="{registry_storage}"
REGISTRY_URL="{registry_url}"
REGISTRY_NAMESPACE="{registry_namespace}"
DEPLOY_DIR_IMAGE="{deploy_dir_image}"

# Baked-in defaults from bitbake (can be overridden by CLI or env vars)
DEFAULT_TAG_STRATEGY="{tag_strategy}"
DEFAULT_TARGET_ARCH="{target_arch}"

PID_FILE="/tmp/container-registry.pid"
LOG_FILE="/tmp/container-registry.log"

# Generate tags based on strategy
# Usage: generate_tags "strategy1 strategy2 ..."
# Strategies: timestamp, sha/git, branch, semver, version, latest, arch
generate_tags() {{
    local strategy="${{1:-latest}}"
    local version="${{IMAGE_VERSION:-}}"
    local arch="${{TARGET_ARCH:-$DEFAULT_TARGET_ARCH}}"
    local tags=""

    for strat in $strategy; do
        case "$strat" in
            timestamp)
                tags="$tags $(date +%Y%m%d-%H%M%S)"
                ;;
            sha|git)
                local sha=$(git rev-parse --short HEAD 2>/dev/null || true)
                [ -n "$sha" ] && tags="$tags $sha"
                ;;
            branch)
                local branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || true)
                if [ -n "$branch" ] && [ "$branch" != "HEAD" ]; then
                    # Sanitize: feature/login -> feature-login
                    tags="$tags $(echo $branch | tr '/_' '--')"
                fi
                ;;
            semver)
                if [ -n "$version" ]; then
                    local v="$version"
                    # Strip any suffix like +gitAUTOINC
                    v=$(echo "$v" | cut -d'+' -f1)
                    local major=$(echo "$v" | cut -d. -f1)
                    local minor=$(echo "$v" | cut -d. -f2)
                    local patch=$(echo "$v" | cut -d. -f3)
                    [ -n "$patch" ] && tags="$tags $major.$minor.$patch"
                    [ -n "$minor" ] && tags="$tags $major.$minor"
                    [ -n "$major" ] && [ "$major" != "$v" ] && tags="$tags $major"
                fi
                ;;
            version)
                if [ -n "$version" ]; then
                    local v=$(echo "$version" | cut -d'+' -f1)
                    tags="$tags $v"
                fi
                ;;
            latest)
                tags="$tags latest"
                ;;
            arch)
                if [ -n "$arch" ]; then
                    local arch_tags=""
                    for t in $tags; do
                        [ "$t" != "latest" ] && arch_tags="$arch_tags ${{t}}-${{arch}}"
                    done
                    tags="$tags $arch_tags"
                fi
                ;;
        esac
    done

    # Ensure at least one tag
    [ -z "$tags" ] && tags="latest"
    echo $tags
}}

cmd_start() {{
    if [ -f "$PID_FILE" ] && kill -0 "$(cat $PID_FILE)" 2>/dev/null; then
        echo "Registry already running (PID: $(cat $PID_FILE))"
        return 0
    fi

    if [ ! -x "$REGISTRY_BIN" ]; then
        echo "Error: Registry binary not found at $REGISTRY_BIN"
        echo "Build it with: bitbake docker-distribution-native"
        return 1
    fi

    mkdir -p "$REGISTRY_STORAGE"

    echo "Starting container registry..."
    echo "  URL:     http://$REGISTRY_URL"
    echo "  Storage: $REGISTRY_STORAGE"
    echo "  Config:  $REGISTRY_CONFIG"

    nohup "$REGISTRY_BIN" serve "$REGISTRY_CONFIG" > "$LOG_FILE" 2>&1 &
    echo $! > "$PID_FILE"
    sleep 2

    if kill -0 "$(cat $PID_FILE)" 2>/dev/null; then
        echo "Registry started (PID: $(cat $PID_FILE))"
        echo "Logs: $LOG_FILE"
    else
        echo "Failed to start registry. Check $LOG_FILE"
        cat "$LOG_FILE"
        return 1
    fi
}}

cmd_stop() {{
    if [ ! -f "$PID_FILE" ]; then
        echo "Registry not running"
        return 0
    fi

    local pid=$(cat "$PID_FILE")
    if kill -0 "$pid" 2>/dev/null; then
        echo "Stopping registry (PID: $pid)..."
        kill "$pid"
        rm -f "$PID_FILE"
        echo "Registry stopped"
    else
        rm -f "$PID_FILE"
        echo "Registry not running (stale PID file removed)"
    fi
}}

cmd_status() {{
    if [ -f "$PID_FILE" ] && kill -0 "$(cat $PID_FILE)" 2>/dev/null; then
        echo "Registry running (PID: $(cat $PID_FILE))"
        echo "URL: http://$REGISTRY_URL"
        if curl -s "http://$REGISTRY_URL/v2/" >/dev/null 2>&1; then
            echo "Status: healthy"
        else
            echo "Status: not responding"
        fi
    else
        echo "Registry not running"
        return 1
    fi
}}

cmd_push() {{
    shift  # Remove 'push' from args

    # Parse options and positional args
    local explicit_tags=""
    local strategy="${{CONTAINER_REGISTRY_TAG_STRATEGY:-$DEFAULT_TAG_STRATEGY}}"
    local version="${{IMAGE_VERSION:-}}"
    local image_filter=""

    while [ $# -gt 0 ]; do
        case "$1" in
            --tag|-t)
                explicit_tags="$explicit_tags $2"
                shift 2
                ;;
            --strategy|-s)
                strategy="$2"
                shift 2
                ;;
            --version|-v)
                version="$2"
                shift 2
                ;;
            -*)
                echo "Unknown option: $1"
                return 1
                ;;
            *)
                # Positional arg = image name filter
                if [ -z "$image_filter" ]; then
                    image_filter="$1"
                fi
                shift
                ;;
        esac
    done

    # Explicit tags require an image name
    if [ -n "$explicit_tags" ] && [ -z "$image_filter" ]; then
        echo "Error: --tag requires an image name"
        echo "Usage: $0 push <image> --tag <tag>"
        echo ""
        echo "Examples:"
        echo "  $0 push container-base --tag v1.0.0"
        echo "  $0 push container-base --tag latest --tag v1.0.0"
        echo ""
        echo "To push all images, use a strategy instead:"
        echo "  $0 push --strategy 'timestamp latest'"
        return 1
    fi

    # Export version for generate_tags
    export IMAGE_VERSION="$version"

    if ! curl -s "http://$REGISTRY_URL/v2/" >/dev/null 2>&1; then
        echo "Registry not responding at http://$REGISTRY_URL"
        echo "Start it first: $0 start"
        return 1
    fi

    # Determine tags to use
    local tags
    if [ -n "$explicit_tags" ]; then
        tags="$explicit_tags"
    else
        tags=$(generate_tags "$strategy")
    fi

    if [ -n "$image_filter" ]; then
        echo "Pushing image: $image_filter"
    else
        echo "Pushing all OCI images from $DEPLOY_DIR_IMAGE"
    fi
    echo "To registry: $REGISTRY_URL/$REGISTRY_NAMESPACE/"
    echo "Tags: $tags"
    echo ""

    local found=0
    for oci_dir in "$DEPLOY_DIR_IMAGE"/*-oci; do
        [ -d "$oci_dir" ] || continue
        [ -f "$oci_dir/index.json" ] || continue

        name=$(basename "$oci_dir" | sed 's/-latest-oci$//' | sed 's/-oci$//')
        # Remove machine suffix
        name=$(echo "$name" | sed 's/-qemux86-64//' | sed 's/-qemuarm64//')
        # Remove rootfs timestamp
        name=$(echo "$name" | sed 's/\\.rootfs-[0-9]*//')

        # Filter by image name if specified
        if [ -n "$image_filter" ]; then
            # Match exact name or name.rootfs variant
            case "$name" in
                "$image_filter"|"$image_filter.rootfs")
                    : # match
                    ;;
                *)
                    continue
                    ;;
            esac
        fi

        found=1
        echo "Pushing: $name"
        for tag in $tags; do
            echo "  -> $REGISTRY_URL/$REGISTRY_NAMESPACE/$name:$tag"
            "$SKOPEO_BIN" copy --dest-tls-verify=false \\
                "oci:$oci_dir" \\
                "docker://$REGISTRY_URL/$REGISTRY_NAMESPACE/$name:$tag"
        done
    done

    if [ -n "$image_filter" ] && [ "$found" = "0" ]; then
        echo "Error: Image '$image_filter' not found in $DEPLOY_DIR_IMAGE"
        echo ""
        echo "Available images:"
        for oci_dir in "$DEPLOY_DIR_IMAGE"/*-oci; do
            [ -d "$oci_dir" ] || continue
            [ -f "$oci_dir/index.json" ] || continue
            n=$(basename "$oci_dir" | sed 's/-latest-oci$//' | sed 's/-oci$//' | sed 's/-qemux86-64//' | sed 's/-qemuarm64//' | sed 's/\\.rootfs-[0-9]*//')
            echo "  $n"
        done
        return 1
    fi

    echo ""
    echo "Done. Catalog:"
    cmd_catalog
}}

cmd_catalog() {{
    curl -s "http://$REGISTRY_URL/v2/_catalog" | python3 -m json.tool 2>/dev/null || \\
        curl -s "http://$REGISTRY_URL/v2/_catalog"
}}

cmd_tags() {{
    local image="${{2:-}}"

    if [ -z "$image" ]; then
        echo "Usage: $0 tags <image>"
        echo ""
        echo "Examples:"
        echo "  $0 tags alpine"
        echo "  $0 tags yocto/container-base"
        return 1
    fi

    # Add namespace if not already qualified
    if ! echo "$image" | grep -q '/'; then
        image="$REGISTRY_NAMESPACE/$image"
    fi

    local result=$(curl -s "http://$REGISTRY_URL/v2/$image/tags/list")

    # Check for errors or empty result
    if [ -z "$result" ]; then
        echo "Image not found: $image"
        return 1
    fi

    if echo "$result" | grep -qE '"errors"|NAME_UNKNOWN|MANIFEST_UNKNOWN'; then
        echo "Image not found: $image"
        return 1
    fi

    # Check if tags array is null or empty
    if echo "$result" | python3 -c "import sys,json; d=json.load(sys.stdin); exit(0 if d.get('tags') else 1)" 2>/dev/null; then
        echo "$result" | python3 -m json.tool 2>/dev/null || echo "$result"
    else
        echo "Image not found: $image"
        return 1
    fi
}}

cmd_list() {{
    if ! curl -s "http://$REGISTRY_URL/v2/" >/dev/null 2>&1; then
        echo "Registry not responding at http://$REGISTRY_URL"
        return 1
    fi

    echo "Images in $REGISTRY_URL:"
    echo ""

    local repos=$(curl -s "http://$REGISTRY_URL/v2/_catalog" | python3 -c "import sys,json; print('\\n'.join(json.load(sys.stdin).get('repositories',[])))" 2>/dev/null)

    if [ -z "$repos" ]; then
        echo "  (none)"
        return 0
    fi

    for repo in $repos; do
        local tags=$(curl -s "http://$REGISTRY_URL/v2/$repo/tags/list" | python3 -c "import sys,json; print(' '.join(json.load(sys.stdin).get('tags',[])))" 2>/dev/null)
        if [ -n "$tags" ]; then
            echo "  $repo: $tags"
        else
            echo "  $repo: (no tags)"
        fi
    done
}}

cmd_import() {{
    local source="${{2:-}}"
    local dest_name="${{3:-}}"

    if [ -z "$source" ]; then
        echo "Usage: $0 import <source-image> [local-name]"
        echo ""
        echo "Examples:"
        echo "  $0 import docker.io/library/alpine:latest"
        echo "  $0 import docker.io/library/alpine:latest my-alpine"
        echo "  $0 import quay.io/podman/hello:latest hello"
        echo "  $0 import ghcr.io/owner/image:tag"
        return 1
    fi

    if ! curl -s "http://$REGISTRY_URL/v2/" >/dev/null 2>&1; then
        echo "Registry not responding at http://$REGISTRY_URL"
        echo "Start it first: $0 start"
        return 1
    fi

    # Extract image name if not provided
    if [ -z "$dest_name" ]; then
        # docker.io/library/alpine:latest -> alpine
        # quay.io/podman/hello:latest -> hello
        dest_name=$(echo "$source" | rev | cut -d'/' -f1 | rev | cut -d':' -f1)
    fi

    # Extract tag from source, default to latest
    local tag="latest"
    if echo "$source" | grep -q ':'; then
        tag=$(echo "$source" | rev | cut -d':' -f1 | rev)
    fi

    echo "Importing: $source"
    echo "       To: $REGISTRY_URL/$REGISTRY_NAMESPACE/$dest_name:$tag"
    echo ""

    "$SKOPEO_BIN" copy \\
        --dest-tls-verify=false \\
        "docker://$source" \\
        "docker://$REGISTRY_URL/$REGISTRY_NAMESPACE/$dest_name:$tag"

    echo ""
    echo "Import complete. Pull with:"
    echo "  vdkr --registry $REGISTRY_URL/$REGISTRY_NAMESPACE pull $dest_name"
    echo "  # or configure: vdkr vconfig registry $REGISTRY_URL/$REGISTRY_NAMESPACE"
    echo "  # then: vdkr pull $dest_name"
}}

cmd_delete() {{
    local image="${{2:-}}"

    if [ -z "$image" ]; then
        echo "Usage: $0 delete <image>[:<tag>]"
        echo ""
        echo "Examples:"
        echo "  $0 delete container-base:v1.0.0     # Delete specific tag"
        echo "  $0 delete container-base:20260112-143022"
        echo "  $0 delete yocto/alpine:latest       # With namespace"
        echo ""
        echo "Note: Deleting a tag removes the manifest reference."
        echo "Run garbage collection to reclaim disk space."
        return 1
    fi

    if ! curl -s "http://$REGISTRY_URL/v2/" >/dev/null 2>&1; then
        echo "Registry not responding at http://$REGISTRY_URL"
        return 1
    fi

    # Parse image:tag
    local name tag
    if echo "$image" | grep -q ':'; then
        name=$(echo "$image" | rev | cut -d':' -f2- | rev)
        tag=$(echo "$image" | rev | cut -d':' -f1 | rev)
    else
        echo "Error: Tag required. Use format: <image>:<tag>"
        echo "Example: $0 delete container-base:v1.0.0"
        return 1
    fi

    # Add namespace if not already qualified
    if ! echo "$name" | grep -q '/'; then
        name="$REGISTRY_NAMESPACE/$name"
    fi

    echo "Deleting: $name:$tag"

    # Get the digest for the tag (try OCI format first, then Docker V2)
    local digest=""
    for accept in "application/vnd.oci.image.manifest.v1+json" \
                  "application/vnd.docker.distribution.manifest.v2+json"; do
        digest=$(curl -s -I -H "Accept: $accept" \
            "http://$REGISTRY_URL/v2/$name/manifests/$tag" 2>/dev/null \
            | grep -i "docker-content-digest" | awk '{{print $2}}' | tr -d '\r\n')
        [ -n "$digest" ] && break
    done

    if [ -z "$digest" ]; then
        echo "Error: Tag not found: $name:$tag"
        return 1
    fi

    echo "  Digest: $digest"

    # Delete by digest
    local status=$(curl -s -o /dev/null -w "%{{http_code}}" -X DELETE \
        "http://$REGISTRY_URL/v2/$name/manifests/$digest")

    if [ "$status" = "202" ]; then
        echo "  Deleted successfully"
        echo ""
        echo "Note: Run garbage collection to reclaim disk space:"
        echo "  $0 gc"
    elif [ "$status" = "405" ]; then
        echo "Error: Deletion not enabled in registry config"
        echo "Add 'storage.delete.enabled: true' to registry config and restart"
        return 1
    else
        echo "Error: Delete failed (HTTP $status)"
        return 1
    fi
}}

cmd_gc() {{
    echo "Running garbage collection..."
    echo ""

    if [ ! -x "$REGISTRY_BIN" ]; then
        echo "Error: Registry binary not found at $REGISTRY_BIN"
        echo "Build it with: bitbake docker-distribution-native"
        return 1
    fi

    # Check if registry is running
    local was_running=0
    if [ -f "$PID_FILE" ] && kill -0 "$(cat $PID_FILE)" 2>/dev/null; then
        was_running=1
        echo "Stopping registry for garbage collection..."
        cmd_stop
        sleep 1
    fi

    echo "Collecting garbage from: $REGISTRY_STORAGE"
    echo ""

    # Run garbage collection (dry-run first to show what would be deleted)
    "$REGISTRY_BIN" garbage-collect --dry-run "$REGISTRY_CONFIG" 2>&1 || true
    echo ""

    read -p "Proceed with garbage collection? [y/N] " confirm
    if [ "$confirm" = "y" ] || [ "$confirm" = "Y" ]; then
        "$REGISTRY_BIN" garbage-collect "$REGISTRY_CONFIG"
        echo ""
        echo "Garbage collection complete."
    else
        echo "Cancelled."
    fi

    # Restart if it was running
    if [ "$was_running" = "1" ]; then
        echo ""
        echo "Restarting registry..."
        cmd_start
    fi
}}

cmd_help() {{
    echo "Usage: $0 <command> [options]"
    echo ""
    echo "Commands:"
    echo "  start                  Start the container registry server"
    echo "  stop                   Stop the container registry server"
    echo "  status                 Check if registry is running"
    echo "  push [image] [opts]    Push OCI images to registry"
    echo "  import <image> [name]  Import 3rd party image to registry"
    echo "  delete <image>:<tag>   Delete a tagged image from registry"
    echo "  gc                     Garbage collect unreferenced blobs"
    echo "  list                   List all images with tags"
    echo "  tags <image>           List tags for an image"
    echo "  catalog                List image names (raw API)"
    echo "  help                   Show this help"
    echo ""
    echo "Push options:"
    echo "  <image>                Image name (required when using --tag)"
    echo "  --tag, -t <tag>        Explicit tag (can be repeated, requires image name)"
    echo "  --strategy, -s <str>   Tag strategy (default: $DEFAULT_TAG_STRATEGY)"
    echo "  --version, -v <ver>    Version for semver strategy (e.g., 1.2.3)"
    echo ""
    echo "Tag strategies (can combine: 'sha branch latest'):"
    echo "  timestamp              YYYYMMDD-HHMMSS format"
    echo "  sha, git               Short git commit hash"
    echo "  branch                 Git branch name (sanitized)"
    echo "  semver                 Nested SemVer (1.2.3 -> 1.2.3, 1.2, 1)"
    echo "  version                Single version tag from --version"
    echo "  latest                 The 'latest' tag"
    echo "  arch                   Append architecture suffix to other tags"
    echo ""
    echo "Examples:"
    echo "  $0 start"
    echo "  $0 push                                    # Push all, default strategy"
    echo "  $0 push container-base                     # Push one, default strategy"
    echo "  $0 push container-base --tag v1.0.0        # Explicit tag (one image)"
    echo "  $0 push container-base -t latest -t v1.0.0 # Multiple explicit tags"
    echo "  $0 push --strategy 'sha branch latest'     # All images, strategy"
    echo "  $0 push --strategy semver --version 1.2.3  # All images, SemVer"
    echo "  $0 import docker.io/library/alpine:latest"
    echo "  $0 import docker.io/library/busybox:latest my-busybox"
    echo "  $0 delete container-base:20260112-143022"
    echo "  $0 list"
    echo "  $0 tags container-base"
    echo ""
    echo "Environment variables:"
    echo "  CONTAINER_REGISTRY_TAG_STRATEGY   Override default tag strategy"
    echo "  IMAGE_VERSION                     Version for semver/version strategies"
    echo "  TARGET_ARCH                       Architecture for arch strategy"
    echo ""
    echo "Configuration (baked from bitbake):"
    echo "  Registry URL:   $REGISTRY_URL"
    echo "  Namespace:      $REGISTRY_NAMESPACE"
    echo "  Tag strategy:   $DEFAULT_TAG_STRATEGY"
    echo "  Target arch:    $DEFAULT_TARGET_ARCH"
    echo "  Storage:        $REGISTRY_STORAGE"
    echo "  Deploy images:  $DEPLOY_DIR_IMAGE"
}}

case "${{1:-help}}" in
    start)   cmd_start ;;
    stop)    cmd_stop ;;
    status)  cmd_status ;;
    push)    cmd_push "$@" ;;
    import)  cmd_import "$@" ;;
    delete)  cmd_delete "$@" ;;
    gc)      cmd_gc ;;
    list)    cmd_list ;;
    tags)    cmd_tags "$@" ;;
    catalog) cmd_catalog ;;
    help|--help|-h) cmd_help ;;
    *) echo "Unknown command: $1"; cmd_help; exit 1 ;;
esac
'''

    with open(script_path, 'w') as f:
        f.write(script)

    # Make executable
    os.chmod(script_path, os.stat(script_path).st_mode | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH)

    bb.plain("")
    bb.plain("=" * 70)
    bb.plain("Generated container registry helper script:")
    bb.plain(f"  {script_path}")
    bb.plain("")
    bb.plain("Usage:")
    bb.plain(f"  {script_path} start    # Start registry server")
    bb.plain(f"  {script_path} push     # Push OCI images to registry")
    bb.plain(f"  {script_path} catalog  # List images in registry")
    bb.plain(f"  {script_path} stop     # Stop registry server")
    bb.plain("=" * 70)
    bb.plain("")
}

do_generate_registry_script[depends] += "docker-distribution-native:do_populate_sysroot skopeo-native:do_populate_sysroot"
addtask do_generate_registry_script

EXCLUDE_FROM_WORLD = "1"
