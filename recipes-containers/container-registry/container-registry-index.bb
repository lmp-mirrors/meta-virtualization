# SPDX-FileCopyrightText: Copyright (C) 2025 Bruce Ashfield
#
# SPDX-License-Identifier: MIT
#
# container-registry-index.bb
# ===========================================================================
# Push OCI container images to a registry (like package-index for containers)
# ===========================================================================
#
# This is the container equivalent of meta/recipes-core/meta/package-index.bb
# It discovers OCI images in DEPLOY_DIR_IMAGE and pushes them to a registry.
#
# Usage:
#   # Start registry first (separate terminal):
#   oe-run-native docker-distribution-native registry serve config.yml
#
#   # Push all container images to registry:
#   bitbake container-registry-index
#
#   # Or use the helper script:
#   oe-run-native container-registry-index
#
# Configuration (in local.conf):
#   CONTAINER_REGISTRY_URL = "localhost:5000"
#   CONTAINER_REGISTRY_NAMESPACE = "yocto"
#   CONTAINER_REGISTRY_IMAGES = "container-base container-app"  # optional filter
#
# ===========================================================================

SUMMARY = "Populate container registry with OCI images"
LICENSE = "MIT"

INHIBIT_DEFAULT_DEPS = "1"
PACKAGES = ""

inherit nopackages container-registry

deltask do_fetch
deltask do_unpack
deltask do_patch
deltask do_configure
deltask do_compile
deltask do_install
deltask do_populate_lic
deltask do_populate_sysroot

do_container_registry_index[nostamp] = "1"
do_container_registry_index[network] = "1"
do_container_registry_index[depends] += "skopeo-native:do_populate_sysroot"

python do_container_registry_index() {
    import os

    registry = d.getVar('CONTAINER_REGISTRY_URL')
    namespace = d.getVar('CONTAINER_REGISTRY_NAMESPACE')
    specific_images = (d.getVar('CONTAINER_REGISTRY_IMAGES') or '').split()

    bb.plain(f"Container Registry Index: {registry}/{namespace}/")

    # Discover OCI images
    all_images = container_registry_discover_oci_images(d)

    if not all_images:
        bb.warn("No OCI images found in deploy directory")
        bb.plain(f"Deploy directory: {d.getVar('DEPLOY_DIR_IMAGE')}")
        bb.plain("Build container images first: bitbake container-base")
        return

    bb.plain(f"Found {len(all_images)} OCI images")

    # Filter if specific images requested
    if specific_images:
        images = [(path, name) for path, name in all_images if name in specific_images]
    else:
        images = all_images

    # Push each image
    pushed_refs = []
    for oci_path, image_name in images:
        bb.plain(f"Pushing: {image_name}")
        refs = container_registry_push(d, oci_path, image_name)
        pushed_refs.extend(refs)

    bb.plain(f"Pushed {len(pushed_refs)} image references to {registry}")
}

addtask do_container_registry_index before do_build

# Generate a helper script with paths baked in
# Script is placed alongside registry storage (outside tmp/) so it persists
CONTAINER_REGISTRY_SCRIPT = "${CONTAINER_REGISTRY_STORAGE}/container-registry.sh"

python do_generate_registry_script() {
    import os
    import stat

    script_path = d.getVar('CONTAINER_REGISTRY_SCRIPT')
    deploy_dir = d.getVar('DEPLOY_DIR')
    deploy_dir_image = d.getVar('DEPLOY_DIR_IMAGE')

    # Find registry binary path
    native_sysroot = d.getVar('STAGING_DIR_NATIVE') or ''
    registry_bin = os.path.join(native_sysroot, 'usr', 'sbin', 'registry')

    # Find skopeo binary path
    skopeo_bin = os.path.join(d.getVar('STAGING_SBINDIR_NATIVE') or '', 'skopeo')

    # Config file path
    config_file = os.path.join(d.getVar('THISDIR'), 'files', 'container-registry-dev.yml')

    # Registry settings
    registry_url = d.getVar('CONTAINER_REGISTRY_URL')
    registry_namespace = d.getVar('CONTAINER_REGISTRY_NAMESPACE')
    registry_storage = d.getVar('CONTAINER_REGISTRY_STORAGE')

    os.makedirs(deploy_dir, exist_ok=True)

    script = f'''#!/bin/bash
# Container Registry Helper Script
# Generated by: bitbake container-registry-index -c generate_registry_script
#
# This script has all paths pre-configured for your build.
#
# Usage:
#   {script_path} start                # Start registry server
#   {script_path} stop                 # Stop registry server
#   {script_path} status               # Check if running
#   {script_path} push                 # Push OCI images to registry
#   {script_path} import <image>       # Import 3rd party image
#   {script_path} list                 # List all images with tags
#   {script_path} tags <image>         # List tags for an image
#   {script_path} catalog              # List image names (raw API)

set -e

# Pre-configured paths from bitbake
REGISTRY_BIN="{registry_bin}"
SKOPEO_BIN="{skopeo_bin}"
REGISTRY_CONFIG="{config_file}"
REGISTRY_STORAGE="{registry_storage}"
REGISTRY_URL="{registry_url}"
REGISTRY_NAMESPACE="{registry_namespace}"
DEPLOY_DIR_IMAGE="{deploy_dir_image}"

PID_FILE="/tmp/container-registry.pid"
LOG_FILE="/tmp/container-registry.log"

cmd_start() {{
    if [ -f "$PID_FILE" ] && kill -0 "$(cat $PID_FILE)" 2>/dev/null; then
        echo "Registry already running (PID: $(cat $PID_FILE))"
        return 0
    fi

    if [ ! -x "$REGISTRY_BIN" ]; then
        echo "Error: Registry binary not found at $REGISTRY_BIN"
        echo "Build it with: bitbake docker-distribution-native"
        return 1
    fi

    mkdir -p "$REGISTRY_STORAGE"
    export REGISTRY_STORAGE_FILESYSTEM_ROOTDIRECTORY="$REGISTRY_STORAGE"

    echo "Starting container registry..."
    echo "  URL:     http://$REGISTRY_URL"
    echo "  Storage: $REGISTRY_STORAGE"
    echo "  Config:  $REGISTRY_CONFIG"

    nohup "$REGISTRY_BIN" serve "$REGISTRY_CONFIG" > "$LOG_FILE" 2>&1 &
    echo $! > "$PID_FILE"
    sleep 2

    if kill -0 "$(cat $PID_FILE)" 2>/dev/null; then
        echo "Registry started (PID: $(cat $PID_FILE))"
        echo "Logs: $LOG_FILE"
    else
        echo "Failed to start registry. Check $LOG_FILE"
        cat "$LOG_FILE"
        return 1
    fi
}}

cmd_stop() {{
    if [ ! -f "$PID_FILE" ]; then
        echo "Registry not running"
        return 0
    fi

    local pid=$(cat "$PID_FILE")
    if kill -0 "$pid" 2>/dev/null; then
        echo "Stopping registry (PID: $pid)..."
        kill "$pid"
        rm -f "$PID_FILE"
        echo "Registry stopped"
    else
        rm -f "$PID_FILE"
        echo "Registry not running (stale PID file removed)"
    fi
}}

cmd_status() {{
    if [ -f "$PID_FILE" ] && kill -0 "$(cat $PID_FILE)" 2>/dev/null; then
        echo "Registry running (PID: $(cat $PID_FILE))"
        echo "URL: http://$REGISTRY_URL"
        if curl -s "http://$REGISTRY_URL/v2/" >/dev/null 2>&1; then
            echo "Status: healthy"
        else
            echo "Status: not responding"
        fi
    else
        echo "Registry not running"
        return 1
    fi
}}

cmd_push() {{
    if ! curl -s "http://$REGISTRY_URL/v2/" >/dev/null 2>&1; then
        echo "Registry not responding at http://$REGISTRY_URL"
        echo "Start it first: $0 start"
        return 1
    fi

    echo "Pushing OCI images from $DEPLOY_DIR_IMAGE"
    echo "To registry: $REGISTRY_URL/$REGISTRY_NAMESPACE/"
    echo ""

    for oci_dir in "$DEPLOY_DIR_IMAGE"/*-oci; do
        [ -d "$oci_dir" ] || continue
        [ -f "$oci_dir/index.json" ] || continue

        name=$(basename "$oci_dir" | sed 's/-latest-oci$//' | sed 's/-oci$//')
        # Remove machine suffix
        name=$(echo "$name" | sed 's/-qemux86-64//' | sed 's/-qemuarm64//')
        # Remove rootfs timestamp
        name=$(echo "$name" | sed 's/\\.rootfs-[0-9]*//')

        echo "Pushing: $name"
        "$SKOPEO_BIN" copy --dest-tls-verify=false \\
            "oci:$oci_dir" \\
            "docker://$REGISTRY_URL/$REGISTRY_NAMESPACE/$name:latest"
    done

    echo ""
    echo "Done. Catalog:"
    cmd_catalog
}}

cmd_catalog() {{
    curl -s "http://$REGISTRY_URL/v2/_catalog" | python3 -m json.tool 2>/dev/null || \\
        curl -s "http://$REGISTRY_URL/v2/_catalog"
}}

cmd_tags() {{
    local image="${{2:-}}"

    if [ -z "$image" ]; then
        echo "Usage: $0 tags <image>"
        echo ""
        echo "Examples:"
        echo "  $0 tags alpine"
        echo "  $0 tags yocto/container-base"
        return 1
    fi

    # Add namespace if not already qualified
    if ! echo "$image" | grep -q '/'; then
        image="$REGISTRY_NAMESPACE/$image"
    fi

    local result=$(curl -s "http://$REGISTRY_URL/v2/$image/tags/list")

    # Check for errors or empty result
    if [ -z "$result" ]; then
        echo "Image not found: $image"
        return 1
    fi

    if echo "$result" | grep -qE '"errors"|NAME_UNKNOWN|MANIFEST_UNKNOWN'; then
        echo "Image not found: $image"
        return 1
    fi

    # Check if tags array is null or empty
    if echo "$result" | python3 -c "import sys,json; d=json.load(sys.stdin); exit(0 if d.get('tags') else 1)" 2>/dev/null; then
        echo "$result" | python3 -m json.tool 2>/dev/null || echo "$result"
    else
        echo "Image not found: $image"
        return 1
    fi
}}

cmd_list() {{
    if ! curl -s "http://$REGISTRY_URL/v2/" >/dev/null 2>&1; then
        echo "Registry not responding at http://$REGISTRY_URL"
        return 1
    fi

    echo "Images in $REGISTRY_URL:"
    echo ""

    local repos=$(curl -s "http://$REGISTRY_URL/v2/_catalog" | python3 -c "import sys,json; print('\\n'.join(json.load(sys.stdin).get('repositories',[])))" 2>/dev/null)

    if [ -z "$repos" ]; then
        echo "  (none)"
        return 0
    fi

    for repo in $repos; do
        local tags=$(curl -s "http://$REGISTRY_URL/v2/$repo/tags/list" | python3 -c "import sys,json; print(' '.join(json.load(sys.stdin).get('tags',[])))" 2>/dev/null)
        if [ -n "$tags" ]; then
            echo "  $repo: $tags"
        else
            echo "  $repo: (no tags)"
        fi
    done
}}

cmd_import() {{
    local source="${{2:-}}"
    local dest_name="${{3:-}}"

    if [ -z "$source" ]; then
        echo "Usage: $0 import <source-image> [local-name]"
        echo ""
        echo "Examples:"
        echo "  $0 import docker.io/library/alpine:latest"
        echo "  $0 import docker.io/library/alpine:latest my-alpine"
        echo "  $0 import quay.io/podman/hello:latest hello"
        echo "  $0 import ghcr.io/owner/image:tag"
        return 1
    fi

    if ! curl -s "http://$REGISTRY_URL/v2/" >/dev/null 2>&1; then
        echo "Registry not responding at http://$REGISTRY_URL"
        echo "Start it first: $0 start"
        return 1
    fi

    # Extract image name if not provided
    if [ -z "$dest_name" ]; then
        # docker.io/library/alpine:latest -> alpine
        # quay.io/podman/hello:latest -> hello
        dest_name=$(echo "$source" | rev | cut -d'/' -f1 | rev | cut -d':' -f1)
    fi

    # Extract tag from source, default to latest
    local tag="latest"
    if echo "$source" | grep -q ':'; then
        tag=$(echo "$source" | rev | cut -d':' -f1 | rev)
    fi

    echo "Importing: $source"
    echo "       To: $REGISTRY_URL/$REGISTRY_NAMESPACE/$dest_name:$tag"
    echo ""

    "$SKOPEO_BIN" copy \\
        --dest-tls-verify=false \\
        "docker://$source" \\
        "docker://$REGISTRY_URL/$REGISTRY_NAMESPACE/$dest_name:$tag"

    echo ""
    echo "Import complete. Pull with:"
    echo "  vdkr --registry $REGISTRY_URL/$REGISTRY_NAMESPACE pull $dest_name"
    echo "  # or configure: vdkr vconfig registry $REGISTRY_URL/$REGISTRY_NAMESPACE"
    echo "  # then: vdkr pull $dest_name"
}}

cmd_help() {{
    echo "Usage: $0 <command>"
    echo ""
    echo "Commands:"
    echo "  start                  Start the container registry server"
    echo "  stop                   Stop the container registry server"
    echo "  status                 Check if registry is running"
    echo "  push                   Push all OCI images to registry"
    echo "  import <image> [name]  Import 3rd party image to registry"
    echo "  list                   List all images with tags"
    echo "  tags <image>           List tags for an image"
    echo "  catalog                List image names (raw API)"
    echo "  help                   Show this help"
    echo ""
    echo "Examples:"
    echo "  $0 start"
    echo "  $0 push"
    echo "  $0 import docker.io/library/alpine:latest"
    echo "  $0 import docker.io/library/busybox:latest my-busybox"
    echo "  $0 list"
    echo "  $0 tags container-base"
    echo ""
    echo "Configuration:"
    echo "  Registry URL:  $REGISTRY_URL"
    echo "  Namespace:     $REGISTRY_NAMESPACE"
    echo "  Storage:       $REGISTRY_STORAGE"
    echo "  Deploy images: $DEPLOY_DIR_IMAGE"
}}

case "${{1:-help}}" in
    start)   cmd_start ;;
    stop)    cmd_stop ;;
    status)  cmd_status ;;
    push)    cmd_push ;;
    import)  cmd_import "$@" ;;
    list)    cmd_list ;;
    tags)    cmd_tags "$@" ;;
    catalog) cmd_catalog ;;
    help|--help|-h) cmd_help ;;
    *) echo "Unknown command: $1"; cmd_help; exit 1 ;;
esac
'''

    with open(script_path, 'w') as f:
        f.write(script)

    # Make executable
    os.chmod(script_path, os.stat(script_path).st_mode | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH)

    bb.plain("")
    bb.plain("=" * 70)
    bb.plain("Generated container registry helper script:")
    bb.plain(f"  {script_path}")
    bb.plain("")
    bb.plain("Usage:")
    bb.plain(f"  {script_path} start    # Start registry server")
    bb.plain(f"  {script_path} push     # Push OCI images to registry")
    bb.plain(f"  {script_path} catalog  # List images in registry")
    bb.plain(f"  {script_path} stop     # Stop registry server")
    bb.plain("=" * 70)
    bb.plain("")
}

do_generate_registry_script[depends] += "docker-distribution-native:do_populate_sysroot skopeo-native:do_populate_sysroot"
addtask do_generate_registry_script

EXCLUDE_FROM_WORLD = "1"
